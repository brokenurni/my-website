<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Mini Game Hub - Games by Krizal</title>
  <meta name="theme-color" content="#0ea5e9" />
  <meta name="description" content="A fast, responsive mini-game hub for mobile and desktop by Krizal." />
  <style>
    :root {
      --bg1: #0ea5e9;
      --bg2: #22d3ee;
      --surface: #ffffffee;
      --surface-2: #fafafacc;
      --surface-dark: #1f2937ee;
      --surface-2-dark: #0b1220cc;
      --text: #0f172a;
      --muted: #334155;
      --text-d: #e5e7eb;
      --muted-d: #cbd5e1;
      --accent: #10b981;
      --accent-2: #f59e0b;
      --danger: #ef4444;
      --radius: 16px;
      --shadow: 0 10px 24px rgba(0, 0, 0, .15);
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    html, body {
      height: 100%;
      margin: 0;
      overflow-x: hidden;
    }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial, "Noto Sans";
      color: var(--text);
      background: linear-gradient(135deg, var(--bg1), var(--bg2));
      background-attachment: fixed;
      transition: color .3s ease, background .4s ease;
    }

    body.dark {
      color: var(--text-d);
      background: linear-gradient(135deg, #0b1220, #1f2937);
    }

    .app {
      max-width: 1100px;
      margin-inline: auto;
      padding: 16px;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .topbar {
      position: sticky;
      top: 0;
      z-index: 20;
      display: flex;
      align-items: center;
      gap: 12px;
      justify-content: space-between;
      padding: 12px 16px;
      margin: -16px -16px 16px;
      backdrop-filter: blur(12px);
      background: rgba(255, 255, 255, .18);
      border-radius: 0 0 16px 16px;
    }

    body.dark .topbar {
      background: rgba(0, 0, 0, .35);
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 700;
      letter-spacing: .3px;
    }

    .logo {
      width: 36px;
      height: 36px;
      display: grid;
      place-items: center;
      border-radius: 50%;
      background: conic-gradient(from 210deg, var(--accent), var(--accent-2));
      color: white;
      box-shadow: var(--shadow);
      font-weight: 900;
      font-size: 0.75rem;
    }

    .name {
      font-size: 0.9rem;
    }

    .actions {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .btn {
      border: none;
      border-radius: 12px;
      padding: 12px 18px;
      cursor: pointer;
      background: var(--accent);
      color: white;
      box-shadow: var(--shadow);
      font-weight: 600;
      transition: transform .2s, box-shadow .2s;
      font-size: 0.95rem;
    }

    .btn:active {
      transform: scale(0.95);
    }

    .btn.small {
      padding: 8px 10px;
      font-size: .9rem;
    }

    .btn.secondary {
      background: transparent;
      color: inherit;
      border: 2px solid currentColor;
      box-shadow: none;
    }

    .btn.large {
      padding: 20px 32px;
      font-size: 1.1rem;
      min-width: 200px;
    }

    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 14px;
    }

    .chips {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .chip {
      padding: 10px 14px;
      border-radius: 999px;
      background: var(--surface-2);
      cursor: pointer;
      border: 2px solid transparent;
      transition: all .2s;
    }

    body.dark .chip {
      background: var(--surface-2-dark);
    }

    .chip.active {
      border-color: var(--accent);
      background: var(--accent);
      color: white;
    }

    .search {
      flex: 1;
      min-width: 200px;
      display: flex;
    }

    .search input {
      width: 100%;
      padding: 12px 14px;
      border-radius: 12px;
      border: 1px solid #cbd5e1;
      background: var(--surface);
      font-size: 1rem;
      outline: none;
      transition: border-color .2s;
    }

    .search input:focus {
      border-color: var(--accent);
    }

    body.dark .search input {
      background: var(--surface-dark);
      color: var(--text-d);
      border-color: #334155;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 16px;
      flex: 1;
    }

    .card {
      background: var(--surface);
      border-radius: var(--radius);
      padding: 18px;
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      gap: 10px;
      transition: transform .2s ease, box-shadow .2s;
      cursor: pointer;
    }

    .card:hover {
      transform: translateY(-6px);
      box-shadow: 0 15px 35px rgba(0, 0, 0, .2);
    }

    body.dark .card {
      background: var(--surface-dark);
    }

    .card h3 {
      margin: 0;
      font-size: 1.15rem;
    }

    .tag {
      font-size: .75rem;
      padding: 4px 10px;
      background: var(--accent-2);
      color: white;
      border-radius: 8px;
      width: fit-content;
      font-weight: 600;
    }

    .card .muted {
      opacity: .7;
      font-size: .9rem;
      margin: 0;
    }

    .meta {
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: .9rem;
      gap: 8px;
      margin-top: auto;
    }

    .screen {
      display: none;
      flex: 1;
    }

    .screen.active {
      display: block;
    }

    .gamewrap {
      background: var(--surface);
      border-radius: var(--radius);
      padding: 20px;
      box-shadow: var(--shadow);
      min-height: 400px;
    }

    body.dark .gamewrap {
      background: var(--surface-dark);
    }

    #gameRoot {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      position: relative;
    }

    .bar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }

    canvas {
      display: block;
      margin: 12px auto;
      background: #000;
      width: 100%;
      height: auto;
      max-width: 520px;
      border-radius: 12px;
      touch-action: none;
      box-shadow: var(--shadow);
    }

    .grid-ttt {
      display: grid;
      grid-template-columns: repeat(3, minmax(80px, 1fr));
      gap: 8px;
      max-width: 360px;
      margin: 12px auto;
    }

    .cell {
      width: 100%;
      aspect-ratio: 1/1;
      background: #fff;
      display: grid;
      place-items: center;
      border-radius: 10px;
      font-size: 2.2rem;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0, 0, 0, .2);
      transition: transform .1s;
    }

    .cell:active {
      transform: scale(0.95);
    }

    body.dark .cell {
      background: #111827;
    }

    .memory {
      display: grid;
      grid-template-columns: repeat(4, minmax(70px, 1fr));
      gap: 10px;
      max-width: 480px;
      margin: auto;
    }

    .mcard {
      width: 100%;
      aspect-ratio: 1/1;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 10px;
      display: grid;
      place-items: center;
      font-size: 1.8rem;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0, 0, 0, .2);
      user-select: none;
      transition: transform .1s;
    }

    .mcard:active {
      transform: scale(0.95);
    }

    .mcard.flipped {
      background: #fff;
    }

    body.dark .mcard.flipped {
      background: #0f172a;
    }

    .dpad {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 30;
      display: grid;
      grid-template-columns: repeat(3, 60px);
      gap: 8px;
      align-items: center;
      justify-items: center;
      opacity: .9;
    }

    .padbtn {
      width: 60px;
      height: 60px;
      border-radius: 12px;
      display: grid;
      place-items: center;
      font-size: 1.4rem;
      font-weight: 700;
      background: var(--surface);
      border: 2px solid #cbd5e1;
      box-shadow: var(--shadow);
      cursor: pointer;
      user-select: none;
      transition: transform .1s;
    }

    .padbtn:active {
      transform: scale(0.9);
    }

    body.dark .padbtn {
      background: #0b1220;
      border-color: #334155;
      color: #e5e7eb;
    }

    .spacer {
      visibility: hidden;
    }

    footer {
      text-align: center;
      opacity: .8;
      padding: 24px 8px;
      margin-top: auto;
    }

    .grid-2048 {
      display: inline-grid;
      grid-template-columns: repeat(4, minmax(64px, 1fr));
      gap: 8px;
      max-width: 520px;
      width: 100%;
      background: #bbada0;
      padding: 8px;
      border-radius: 12px;
    }

    .tile-2048 {
      aspect-ratio: 1 / 1;
      border-radius: 8px;
      display: grid;
      place-items: center;
      font-weight: 700;
      font-size: 1.5rem;
      background: #cdc1b4;
      transition: all .15s;
    }

    .brick-game {
      position: relative;
    }

    .brick {
      position: absolute;
      border-radius: 4px;
    }

    .paddle-game {
      position: relative;
    }

    @media (max-width: 768px) {
      .grid {
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      }

      .name {
        display: none;
      }

      .toolbar {
        flex-direction: column;
        align-items: stretch;
      }

      .chips {
        justify-content: center;
      }
    }

    @media (max-width: 480px) {
      .memory {
        grid-template-columns: repeat(4, 1fr);
      }

      .grid-ttt {
        grid-template-columns: repeat(3, 1fr);
      }

      .tile-2048 {
        font-size: 1.2rem;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <header class="topbar">
      <div class="brand">
        <div class="logo">GBK</div>
        <div class="name">GAMES BY KRIZAL</div>
      </div>

      <nav class="actions">
        <button class="btn small secondary" id="themeBtn" title="Toggle Theme">üåô</button>
        <button class="btn small secondary" id="soundBtn" title="Toggle Sound">üîä</button>
        <button class="btn small secondary" id="pauseBtn" title="Pause">‚è∏</button>
      </nav>
    </header>

    <main id="home" class="screen active">
      <section class="toolbar">
        <div class="chips" id="catChips">
          <div class="chip active" data-cat="all">All</div>
          <div class="chip" data-cat="arcade">Arcade</div>
          <div class="chip" data-cat="puzzle">Puzzle</div>
          <div class="chip" data-cat="quick">Quick Play</div>
        </div>

        <div class="search">
          <input type="search" id="search" placeholder="Search games..." />
        </div>
      </section>

      <section class="grid" id="gameGrid"></section>
    </main>

    <section id="gameView" class="screen">
      <div class="bar">
        <button class="btn secondary" id="backBtn">‚¨Ö Back</button>
        <div id="gameMeta" class="meta" style="flex:1"></div>
        <button class="btn small secondary" id="restartBtn">‚Üª Restart</button>
      </div>

      <div class="gamewrap">
        <h2 id="gameTitle" style="margin-top:0; text-align:center;">Game</h2>
        <div id="gameRoot"></div>
      </div>
    </section>

    <div id="dpad" class="dpad" style="display:none">
      <div class="spacer"></div>
      <button class="padbtn" data-dir="up">‚ñ≤</button>
      <div class="spacer"></div>
      <button class="padbtn" data-dir="left">‚óÄ</button>
      <div class="spacer"></div>
      <button class="padbtn" data-dir="right">‚ñ∂</button>
      <div class="spacer"></div>
      <button class="padbtn" data-dir="down">‚ñº</button>
      <div class="spacer"></div>
    </div>

    <footer>
      ¬© <span id="year"></span> Mini Game Hub ‚Äì <strong>BY KRIZAL</strong>
    </footer>
  </div>

  <script>
    const $ = (q, el = document) => el.querySelector(q);
    const $$ = (q, el = document) => [...el.querySelectorAll(q)];

    let SOUND_ENABLED = true;
    let GLOBAL_PAUSED = false;
    let resumeHook = null;
    let currentGameCleanup = null;
    let currentGameInit = null;

    function beep(type = 'click') {
      if (!SOUND_ENABLED) return;
      try {
        const ctx = beep.ctx || (beep.ctx = new (window.AudioContext || window.webkitAudioContext)());
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.connect(g);
        g.connect(ctx.destination);
        let f = 440, t = 0.08;
        if (type === 'win') { f = 880; t = 0.15; }
        if (type === 'lose') { f = 220; t = 0.25; }
        o.frequency.value = f;
        g.gain.value = 0.02;
        o.start();
        setTimeout(() => o.stop(), t * 1000);
      } catch (e) {}
    }

    const themeBtn = $('#themeBtn');
    function setTheme(mode) {
      document.body.classList.toggle('dark', mode === 'dark');
      themeBtn.textContent = mode === 'dark' ? '‚òÄÔ∏è' : 'üåô';
    }
    setTheme('light');
    themeBtn.onclick = () => setTheme(document.body.classList.contains('dark') ? 'light' : 'dark');

    const soundBtn = $('#soundBtn');
    soundBtn.onclick = () => {
      SOUND_ENABLED = !SOUND_ENABLED;
      soundBtn.textContent = SOUND_ENABLED ? 'üîä' : 'üîá';
    };

    const pauseBtn = $('#pauseBtn');
    pauseBtn.onclick = () => {
      GLOBAL_PAUSED = !GLOBAL_PAUSED;
      pauseBtn.textContent = GLOBAL_PAUSED ? '‚ñ∂Ô∏è' : '‚è∏';
      if (resumeHook && !GLOBAL_PAUSED) resumeHook();
    };

    const home = $('#home');
    const gameView = $('#gameView');
    const gameRoot = $('#gameRoot');
    const gameTitle = $('#gameTitle');
    const gameMeta = $('#gameMeta');
    const restartBtn = $('#restartBtn');
    const backBtn = $('#backBtn');

    function showHome() {
      gameView.classList.remove('active');
      home.classList.add('active');
      cleanupCurrentGame();
      toggleDpad(false);
    }

    function showGame() {
      home.classList.remove('active');
      gameView.classList.add('active');
    }

    backBtn.onclick = showHome;

    const dpad = $('#dpad');
    let dpadHandler = null;

    function toggleDpad(show) {
      dpad.style.display = show ? '' : 'none';
    }

    $$('.padbtn').forEach(btn => {
      btn.addEventListener('pointerdown', e => {
        const dir = e.target.dataset.dir;
        if (dir && dpadHandler) {
          dpadHandler(dir);
          e.target.style.transform = 'scale(0.9)';
          setTimeout(() => e.target.style.transform = '', 100);
        }
      });
    });

    function addSwipe(el, cb) {
      let sx = 0, sy = 0, t = 0;
      el.addEventListener('touchstart', e => {
        const p = e.changedTouches[0];
        sx = p.clientX;
        sy = p.clientY;
        t = performance.now();
      }, { passive: true });
      el.addEventListener('touchend', e => {
        const p = e.changedTouches[0];
        const dx = p.clientX - sx;
        const dy = p.clientY - sy;
        const dt = performance.now() - t;
        const adx = Math.abs(dx), ady = Math.abs(dy);
        if (dt < 500 && Math.max(adx, ady) > 30) {
          if (adx > ady) cb(dx > 0 ? 'right' : 'left');
          else cb(dy > 0 ? 'down' : 'up');
        }
      }, { passive: true });
    }

    const GAMES = [
      { id: 'snake', name: 'Snake Classic', cat: 'arcade', desc: 'Eat food, grow longer. Swipe or use arrows!', init: initSnake },
      { id: 'flappy', name: 'Flappy Bird', cat: 'arcade', desc: 'Tap to fly. Avoid the pipes!', init: initFlappy },
      { id: 'pong', name: 'Pong', cat: 'arcade', desc: 'Keep the ball in play. Touch to move paddle.', init: initPong },
      { id: 'breakout', name: 'Breakout', cat: 'arcade', desc: 'Break all the bricks! Move paddle to bounce ball.', init: initBreakout },
      { id: 'spaceshooter', name: 'Space Shooter', cat: 'arcade', desc: 'Shoot asteroids! Tap to fire, drag to move.', init: initSpaceShooter },
      { id: '2048', name: '2048', cat: 'puzzle', desc: 'Merge tiles to reach 2048!', init: init2048 },
      { id: 'memory', name: 'Memory Match', cat: 'puzzle', desc: 'Find all matching pairs quickly.', init: initMemory },
      { id: 'tictactoe', name: 'Tic Tac Toe', cat: 'puzzle', desc: 'Beat the smart AI!', init: initTicTacToe },
      { id: 'simon', name: 'Simon Says', cat: 'quick', desc: 'Remember and repeat the pattern!', init: initSimon },
      { id: 'math', name: 'Math Sprint', cat: 'quick', desc: '10 quick math questions!', init: initMath }
    ];

    const grid = $('#gameGrid');
    document.getElementById("year").textContent = new Date().getFullYear();

    function renderGrid() {
      const q = ($('#search').value || '').toLowerCase();
      const activeCat = $('.chip.active').dataset.cat;
      grid.innerHTML = '';
      GAMES.filter(g => 
        (activeCat === 'all' || g.cat === activeCat) && 
        (g.name.toLowerCase().includes(q) || g.desc.toLowerCase().includes(q))
      ).forEach(g => {
        const card = document.createElement('div');
        card.className = 'card';
        card.innerHTML = `
          <h3>${g.name}</h3>
          <div class="tag">${g.cat.toUpperCase()}</div>
          <p class="muted">${g.desc}</p>
          <div class="meta">
            <span>üéÆ Play Now</span>
            <button class="btn small" data-id="${g.id}">‚ñ∂</button>
          </div>`;
        card.querySelector('button').onclick = () => openGame(g.id);
        grid.appendChild(card);
      });
    }

    $$('#catChips .chip').forEach(c => c.onclick = () => {
      $$('#catChips .chip').forEach(x => x.classList.remove('active'));
      c.classList.add('active');
      renderGrid();
    });
    $('#search').addEventListener('input', renderGrid);
    renderGrid();

    function cleanupCurrentGame() {
      if (currentGameCleanup) {
        try { currentGameCleanup(); } catch (e) {}
      }
      currentGameCleanup = null;
      resumeHook = null;
      gameRoot.innerHTML = '';
      GLOBAL_PAUSED = false;
      pauseBtn.textContent = '‚è∏';
    }

    function openGame(id) {
      const g = GAMES.find(x => x.id === id);
      if (!g) return;
      cleanupCurrentGame();
      gameTitle.textContent = g.name;
      gameMeta.innerHTML = `<div>Category: <b>${g.cat}</b></div>`;
      showGame();
      
      try {
        currentGameInit = () => g.init(gameRoot) || null;
        currentGameCleanup = currentGameInit();
      } catch (e) {
        console.error(e);
        gameRoot.innerHTML = '<p style="color:red">Error loading game</p>';
      }
      
      restartBtn.onclick = () => {
        if (currentGameInit) {
          cleanupCurrentGame();
          currentGameCleanup = currentGameInit();
        }
      };
    }

    // === SNAKE ===
    function initSnake(root) {
      const cvs = document.createElement('canvas');
      cvs.width = 400;
      cvs.height = 400;
      const ctx = cvs.getContext('2d');
      
      const scoreEl = document.createElement('h3');
      scoreEl.style.textAlign = 'center';
      scoreEl.style.margin = '10px 0';
      
      root.append(scoreEl, cvs);

      let snake = [{ x: 200, y: 200 }];
      let food = { x: 80, y: 80 };
      let dx = 20, dy = 0;
      let score = 0;
      let gameOver = false;
      let loop;

      function rnd() { return Math.floor(Math.random() * 20) * 20; }

      function draw() {
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, cvs.width, cvs.height);
        
        ctx.fillStyle = '#ff6b6b';
        ctx.beginPath();
        ctx.arc(food.x + 10, food.y + 10, 8, 0, Math.PI * 2);
        ctx.fill();
        
        snake.forEach((s, i) => {
          ctx.fillStyle = i === 0 ? '#4ecdc4' : '#45b7aa';
          ctx.fillRect(s.x + 1, s.y + 1, 18, 18);
        });

        scoreEl.textContent = `Score: ${score}`;

        if (gameOver) {
          ctx.fillStyle = 'rgba(0,0,0,0.8)';
          ctx.fillRect(0, 0, cvs.width, cvs.height);
          ctx.fillStyle = 'white';
          ctx.font = 'bold 28px system-ui';
          ctx.textAlign = 'center';
          ctx.fillText('Game Over!', cvs.width/2, cvs.height/2 - 20);
          ctx.font = '20px system-ui';
          ctx.fillText(`Final Score: ${score}`, cvs.width/2, cvs.height/2 + 20);
        }
      }

      function step() {
        if (GLOBAL_PAUSED || gameOver) return;
        
        const head = { x: snake[0].x + dx, y: snake[0].y + dy };
        
        if (head.x < 0 || head.y < 0 || head.x >= cvs.width || head.y >= cvs.height ||
            snake.some(s => s.x === head.x && s.y === head.y)) {
          gameOver = true;
          beep('lose');
          draw();
          return;
        }

        snake.unshift(head);

        if (head.x === food.x && head.y === food.y) {
          score++;
          beep('win');
          food = { x: rnd(), y: rnd() };
        } else {
          snake.pop();
        }

        draw();
      }

      function setDir(dir) {
        if (dir === 'up' && dy === 0) { dx = 0; dy = -20; }
        else if (dir === 'down' && dy === 0) { dx = 0; dy = 20; }
        else if (dir === 'left' && dx === 0) { dx = -20; dy = 0; }
        else if (dir === 'right' && dx === 0) { dx = 20; dy = 0; }
      }

      const keyHandler = e => {
        if (e.key.startsWith('Arrow')) {
          e.preventDefault();
          setDir(e.key.replace('Arrow', '').toLowerCase());
        }
      };

      window.addEventListener('keydown', keyHandler);
      addSwipe(cvs, setDir);
      dpadHandler = setDir;
      toggleDpad(true);

      draw();
      loop = setInterval(step, 120);

      return () => {
        clearInterval(loop);
        window.removeEventListener('keydown', keyHandler);
        toggleDpad(false);
        dpadHandler = null;
      };
    }

    // === FLAPPY BIRD ===
    function initFlappy(root) {
      const cvs = document.createElement('canvas');
      cvs.width = 360;
      cvs.height = 500;
      const ctx = cvs.getContext('2d');
      root.appendChild(cvs);

      let bird = { x: 80, y: 250, vy: 0, r: 15 };
      const gravity = 0.5;
      const jumpPower = -9;
      let pipes = [];
      let score = 0;
      let gameOver = false;
      let started = false;
      let frame = 0;

      function createPipe() {
        const gap = 150;
        const minHeight = 60;
        const maxHeight = cvs.height - gap - 100;
        const height = minHeight + Math.random() * (maxHeight - minHeight);
        pipes.push({
          x: cvs.width,
          topHeight: height,
          gap: gap,
          scored: false
        });
      }

      function reset() {
        bird = { x: 80, y: 250, vy: 0, r: 15 };
        pipes = [];
        score = 0;
        gameOver = false;
        started = false;
        frame = 0;
        createPipe();
        createPipe();
        pipes[1].x = cvs.width + 200;
      }

      function draw() {
        ctx.fillStyle = '#4cc9f0';
        ctx.fillRect(0, 0, cvs.width, cvs.height);
        
        ctx.fillStyle = '#2a9d8f';
        pipes.forEach(p => {
          ctx.fillRect(p.x, 0, 60, p.topHeight);
          ctx.fillRect(p.x, p.topHeight + p.gap, 60, cvs.height);
        });
        
        ctx.fillStyle = '#ffd60a';
        ctx.beginPath();
        ctx.arc(bird.x, bird.y, bird.r, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = 'white';
        ctx.font = 'bold 32px system-ui';
        ctx.fillText(score, cvs.width / 2, 50);

        if (!started) {
          ctx.fillStyle = 'rgba(0,0,0,0.5)';
          ctx.fillRect(0, 0, cvs.width, cvs.height);
          ctx.fillStyle = 'white';
          ctx.font = 'bold 24px system-ui';
          ctx.textAlign = 'center';
          ctx.fillText('TAP TO START', cvs.width/2, cvs.height/2);
          ctx.textAlign = 'left';
        }
        
        if (gameOver) {
          ctx.fillStyle = 'rgba(0,0,0,0.7)';
          ctx.fillRect(0, 0, cvs.width, cvs.height);
          ctx.fillStyle = 'white';
          ctx.font = 'bold 32px system-ui';
          ctx.textAlign = 'center';
          ctx.fillText('Game Over!', cvs.width/2, cvs.height/2 - 30);
          ctx.font = '20px system-ui';
          ctx.fillText(`Score: ${score}`, cvs.width/2, cvs.height/2 + 10);
          ctx.fillText('Tap to Restart', cvs.width/2, cvs.height/2 + 50);
          ctx.textAlign = 'left';
        }
      }

      function update() {
        if (GLOBAL_PAUSED || gameOver || !started) return;

        frame++;
        if (frame % 100 === 0) createPipe();

        bird.vy += gravity;
        bird.y += bird.vy;

        pipes.forEach(p => {
          p.x -= 3;
          
          if (!p.scored && p.x + 60 < bird.x) {
            p.scored = true;
            score++;
            beep('win');
          }
        });

        pipes = pipes.filter(p => p.x > -60);

        for (const p of pipes) {
          if (bird.x + bird.r > p.x && bird.x - bird.r < p.x + 60) {
            if (bird.y - bird.r < p.topHeight || bird.y + bird.r > p.topHeight + p.gap) {
              gameOver = true;
              beep('lose');
              return;
            }
          }
        }

        if (bird.y - bird.r < 0 || bird.y + bird.r > cvs.height) {
          gameOver = true;
          beep('lose');
        }
      }

      function gameLoop() {
        update();
        draw();
        requestAnimationFrame(gameLoop);
      }

      function handleTap() {
        if (gameOver) {
          reset();
          started = true;
        } else if (!started) {
          started = true;
        } else {
          bird.vy = jumpPower;
          beep('click');
        }
      }

      cvs.addEventListener('pointerdown', handleTap);
      const keyHandler = e => {
        if (e.code === 'Space' || e.key === ' ') {
          e.preventDefault();
          handleTap();
        }
      };
      window.addEventListener('keydown', keyHandler);

      reset();
      gameLoop();

      return () => {
        cvs.removeEventListener('pointerdown', handleTap);
        window.removeEventListener('keydown', keyHandler);
      };
    }

    // === PONG ===
    function initPong(root) {
      const cvs = document.createElement('canvas');
      cvs.width = 500;
      cvs.height = 350;
      const ctx = cvs.getContext('2d');
      
      const scoreEl = document.createElement('h3');
      scoreEl.style.textAlign = 'center';
      
      root.append(scoreEl, cvs);

      let ball = { x: 250, y: 175, vx: 4, vy: 3, r: 8 };
      let playerY = 175;
      let aiY = 175;
      const paddleW = 12, paddleH = 80;
      let score = 0;
      let aiScore = 0;
      let animationId = null;
      let isRunning = true;

      function draw() {
        ctx.fillStyle = '#001219';
        ctx.fillRect(0, 0, cvs.width, cvs.height);
        
        ctx.strokeStyle = '#ffffff22';
        ctx.setLineDash([10, 10]);
        ctx.beginPath();
        ctx.moveTo(cvs.width/2, 0);
        ctx.lineTo(cvs.width/2, cvs.height);
        ctx.stroke();
        ctx.setLineDash([]);
        
        ctx.fillStyle = '#06ffa5';
        ctx.fillRect(10, playerY - paddleH/2, paddleW, paddleH);
        
        ctx.fillStyle = '#ff006e';
        ctx.fillRect(cvs.width - 10 - paddleW, aiY - paddleH/2, paddleW, paddleH);
        
        ctx.fillStyle = '#ffbe0b';
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
        ctx.fill();

        scoreEl.textContent = `You: ${score} | AI: ${aiScore}`;
      }

      function update() {
        if (!isRunning) return;
        if (GLOBAL_PAUSED) {
          animationId = requestAnimationFrame(update);
          return;
        }
        
        ball.x += ball.vx;
        ball.y += ball.vy;

        if (ball.y - ball.r < 0 || ball.y + ball.r > cvs.height) {
          ball.vy *= -1;
          ball.y = ball.y - ball.r < 0 ? ball.r : cvs.height - ball.r;
        }

        aiY += (ball.y - aiY) * 0.08;
        aiY = Math.max(paddleH/2, Math.min(cvs.height - paddleH/2, aiY));

        if (ball.x - ball.r < 10 + paddleW && ball.x - ball.r > 10 && 
            ball.y > playerY - paddleH/2 && ball.y < playerY + paddleH/2) {
          ball.vx = Math.abs(ball.vx) * 1.05;
          ball.x = 10 + paddleW + ball.r;
          ball.vy += (ball.y - playerY) * 0.1;
          score++;
          beep('win');
        }

        if (ball.x + ball.r > cvs.width - 10 - paddleW && ball.x + ball.r < cvs.width - 10 &&
            ball.y > aiY - paddleH/2 && ball.y < aiY + paddleH/2) {
          ball.vx = -Math.abs(ball.vx) * 1.05;
          ball.x = cvs.width - 10 - paddleW - ball.r;
          ball.vy += (ball.y - aiY) * 0.1;
          beep('click');
        }

        if (ball.x < 0) {
          aiScore++;
          beep('lose');
          ball = { x: 250, y: 175, vx: 4, vy: 3, r: 8 };
        }

        if (ball.x > cvs.width) {
          ball = { x: 250, y: 175, vx: -4, vy: 3, r: 8 };
        }

        draw();
        animationId = requestAnimationFrame(update);
      }

      function handleMove(e) {
        const rect = cvs.getBoundingClientRect();
        const y = (e.clientY - rect.top) / rect.height * cvs.height;
        playerY = Math.max(paddleH/2, Math.min(cvs.height - paddleH/2, y));
      }

      cvs.addEventListener('pointermove', handleMove);
      cvs.addEventListener('pointerdown', handleMove);

      draw();
      update();

      resumeHook = () => {
        if (isRunning && !animationId) update();
      };

      return () => {
        isRunning = false;
        if (animationId) cancelAnimationFrame(animationId);
        cvs.removeEventListener('pointermove', handleMove);
        cvs.removeEventListener('pointerdown', handleMove);
      };
    }

    // === BREAKOUT ===
    function initBreakout(root) {
      const cvs = document.createElement('canvas');
      cvs.width = 480;
      cvs.height = 400;
      const ctx = cvs.getContext('2d');
      
      const scoreEl = document.createElement('h3');
      scoreEl.style.textAlign = 'center';
      
      root.append(scoreEl, cvs);

      let ball = { x: 240, y: 300, vx: 4, vy: -4, r: 8 };
      let paddle = { x: 200, y: 370, w: 80, h: 12 };
      let bricks = [];
      let score = 0;
      let gameOver = false;
      let won = false;

      const rows = 5, cols = 8;
      const brickW = 55, brickH = 20;

      function initBricks() {
        bricks = [];
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            bricks.push({
              x: c * (brickW + 5) + 15,
              y: r * (brickH + 5) + 40,
              w: brickW,
              h: brickH,
              alive: true,
              color: `hsl(${r * 40}, 70%, 60%)`
            });
          }
        }
      }

      function draw() {
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, cvs.width, cvs.height);
        
        bricks.forEach(b => {
          if (b.alive) {
            ctx.fillStyle = b.color;
            ctx.fillRect(b.x, b.y, b.w, b.h);
          }
        });
        
        ctx.fillStyle = '#4ecdc4';
        ctx.fillRect(paddle.x, paddle.y, paddle.w, paddle.h);
        
        ctx.fillStyle = '#ff6b6b';
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
        ctx.fill();

        scoreEl.textContent = `Score: ${score}`;

        if (gameOver) {
          ctx.fillStyle = 'rgba(0,0,0,0.8)';
          ctx.fillRect(0, 0, cvs.width, cvs.height);
          ctx.fillStyle = 'white';
          ctx.font = 'bold 28px system-ui';
          ctx.textAlign = 'center';
          ctx.fillText(won ? 'üéâ You Won!' : 'Game Over!', cvs.width/2, cvs.height/2 - 20);
          ctx.font = '20px system-ui';
          ctx.fillText(`Score: ${score}`, cvs.width/2, cvs.height/2 + 20);
        }
      }

      function update() {
        if (GLOBAL_PAUSED || gameOver) return;
        
        ball.x += ball.vx;
        ball.y += ball.vy;

        if (ball.x - ball.r < 0 || ball.x + ball.r > cvs.width) ball.vx *= -1;
        if (ball.y - ball.r < 0) ball.vy *= -1;

        if (ball.y + ball.r > paddle.y && ball.y - ball.r < paddle.y + paddle.h &&
            ball.x > paddle.x && ball.x < paddle.x + paddle.w) {
          ball.vy = -Math.abs(ball.vy);
          ball.vx += (ball.x - (paddle.x + paddle.w/2)) * 0.1;
          beep('click');
        }

        bricks.forEach(b => {
          if (b.alive && ball.x + ball.r > b.x && ball.x - ball.r < b.x + b.w &&
              ball.y + ball.r > b.y && ball.y - ball.r < b.y + b.h) {
            b.alive = false;
            ball.vy *= -1;
            score += 10;
            beep('win');
          }
        });

        if (ball.y > cvs.height) {
          gameOver = true;
          beep('lose');
        }

        if (bricks.every(b => !b.alive)) {
          gameOver = true;
          won = true;
          beep('win');
        }

        draw();
        requestAnimationFrame(update);
      }

      function handleMove(e) {
        const rect = cvs.getBoundingClientRect();
        let x = (e.clientX - rect.left) / rect.width * cvs.width;
        paddle.x = Math.max(0, Math.min(cvs.width - paddle.w, x - paddle.w/2));
      }

      cvs.addEventListener('pointermove', handleMove);
      cvs.addEventListener('pointerdown', handleMove);

      initBricks();
      draw();
      update();

      return () => {
        cvs.removeEventListener('pointermove', handleMove);
        cvs.removeEventListener('pointerdown', handleMove);
      };
    }

    // === SPACE SHOOTER ===
    function initSpaceShooter(root) {
      const cvs = document.createElement('canvas');
      cvs.width = 400;
      cvs.height = 500;
      const ctx = cvs.getContext('2d');
      
      const scoreEl = document.createElement('h3');
      scoreEl.style.textAlign = 'center';
      
      root.append(scoreEl, cvs);

      let ship = { x: 200, y: 450, w: 30, h: 30 };
      let bullets = [];
      let asteroids = [];
      let score = 0;
      let gameOver = false;
      let frame = 0;

      function spawnAsteroid() {
        asteroids.push({
          x: Math.random() * (cvs.width - 30),
          y: -30,
          r: 15 + Math.random() * 15,
          vy: 2 + Math.random() * 2
        });
      }

      function draw() {
        ctx.fillStyle = '#0a0e27';
        ctx.fillRect(0, 0, cvs.width, cvs.height);
        
        for (let i = 0; i < 50; i++) {
          ctx.fillStyle = 'white';
          ctx.fillRect((i * 37) % cvs.width, (i * 53 + frame) % cvs.height, 2, 2);
        }
        
        ctx.fillStyle = '#4ecdc4';
        ctx.beginPath();
        ctx.moveTo(ship.x, ship.y);
        ctx.lineTo(ship.x - 15, ship.y + 30);
        ctx.lineTo(ship.x + 15, ship.y + 30);
        ctx.closePath();
        ctx.fill();
        
        ctx.fillStyle = '#ffd60a';
        bullets.forEach(b => {
          ctx.fillRect(b.x - 2, b.y, 4, 10);
        });
        
        ctx.fillStyle = '#ff6b6b';
        asteroids.forEach(a => {
          ctx.beginPath();
          ctx.arc(a.x, a.y, a.r, 0, Math.PI * 2);
          ctx.fill();
        });

        scoreEl.textContent = `Score: ${score}`;

        if (gameOver) {
          ctx.fillStyle = 'rgba(0,0,0,0.8)';
          ctx.fillRect(0, 0, cvs.width, cvs.height);
          ctx.fillStyle = 'white';
          ctx.font = 'bold 28px system-ui';
          ctx.textAlign = 'center';
          ctx.fillText('Game Over!', cvs.width/2, cvs.height/2 - 20);
          ctx.font = '20px system-ui';
          ctx.fillText(`Score: ${score}`, cvs.width/2, cvs.height/2 + 20);
        }
      }

      function update() {
        if (GLOBAL_PAUSED || gameOver) return;
        
        frame++;
        if (frame % 60 === 0) spawnAsteroid();

        bullets.forEach(b => b.y -= 8);
        bullets = bullets.filter(b => b.y > 0);

        asteroids.forEach(a => a.y += a.vy);
        
        bullets.forEach((b, bi) => {
          asteroids.forEach((a, ai) => {
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            if (Math.sqrt(dx*dx + dy*dy) < a.r) {
              bullets.splice(bi, 1);
              asteroids.splice(ai, 1);
              score += 10;
              beep('win');
            }
          });
        });

        asteroids.forEach(a => {
          const dx = ship.x - a.x;
          const dy = ship.y + 15 - a.y;
          if (Math.sqrt(dx*dx + dy*dy) < a.r + 15) {
            gameOver = true;
            beep('lose');
          }
        });

        asteroids = asteroids.filter(a => a.y < cvs.height + 30);

        draw();
        requestAnimationFrame(update);
      }

      function shoot() {
        bullets.push({ x: ship.x, y: ship.y });
        beep('click');
      }

      function handleMove(e) {
        const rect = cvs.getBoundingClientRect();
        ship.x = Math.max(15, Math.min(cvs.width - 15, (e.clientX - rect.left) / rect.width * cvs.width));
      }

      cvs.addEventListener('pointermove', handleMove);
      cvs.addEventListener('pointerdown', e => {
        handleMove(e);
        shoot();
      });

      const keyHandler = e => {
        if (e.code === 'Space') {
          e.preventDefault();
          shoot();
        }
      };
      window.addEventListener('keydown', keyHandler);

      draw();
      update();

      return () => {
        cvs.removeEventListener('pointermove', handleMove);
        cvs.removeEventListener('pointerdown', handleMove);
        window.removeEventListener('keydown', keyHandler);
      };
    }

    // === 2048 ===
    function init2048(root) {
      const size = 4;
      let grid = Array.from({ length: size }, () => Array(size).fill(0));
      let score = 0;

      const scoreEl = document.createElement('h3');
      scoreEl.style.textAlign = 'center';
      
      const wrap = document.createElement('div');
      wrap.className = 'grid-2048';
      
      const tiles = [];
      for (let r = 0; r < size; r++) {
        for (let c = 0; c < size; c++) {
          const d = document.createElement('div');
          d.className = 'tile-2048';
          tiles.push(d);
          wrap.appendChild(d);
        }
      }

      root.append(scoreEl, wrap);

      function spawn() {
        const empty = [];
        for (let r = 0; r < size; r++)
          for (let c = 0; c < size; c++)
            if (!grid[r][c]) empty.push([r, c]);
        if (!empty.length) return;
        const [r, c] = empty[Math.floor(Math.random() * empty.length)];
        grid[r][c] = Math.random() < 0.9 ? 2 : 4;
      }

      function draw() {
        for (let r = 0; r < size; r++) {
          for (let c = 0; c < size; c++) {
            const v = grid[r][c];
            const d = tiles[r * size + c];
            d.textContent = v || '';
            
            const colors = {
              0: '#cdc1b4', 2: '#eee4da', 4: '#ede0c8',
              8: '#f2b179', 16: '#f59563', 32: '#f67c5f',
              64: '#f65e3b', 128: '#edcf72', 256: '#edcc61',
              512: '#edc850', 1024: '#edc53f', 2048: '#edc22e'
            };
            d.style.background = colors[v] || '#3c3a32';
            d.style.color = v > 4 ? 'white' : '#776e65';
          }
        }
        scoreEl.textContent = `Score: ${score}`;
      }

      function slide(row) {
        row = row.filter(v => v);
        for (let i = 0; i < row.length - 1; i++) {
          if (row[i] === row[i + 1]) {
            row[i] *= 2;
            score += row[i];
            row[i + 1] = 0;
          }
        }
        return row.filter(v => v);
      }

      function move(dir) {
        let moved = false;
        const oldGrid = grid.map(r => [...r]);

        if (dir === 'left' || dir === 'right') {
          for (let r = 0; r < size; r++) {
            let row = [...grid[r]];
            if (dir === 'right') row = row.reverse();
            row = slide(row);
            while (row.length < size) row.push(0);
            if (dir === 'right') row = row.reverse();
            grid[r] = row;
          }
        } else {
          for (let c = 0; c < size; c++) {
            let col = [];
            for (let r = 0; r < size; r++) col.push(grid[r][c]);
            if (dir === 'down') col = col.reverse();
            col = slide(col);
            while (col.length < size) col.push(0);
            if (dir === 'down') col = col.reverse();
            for (let r = 0; r < size; r++) grid[r][c] = col[r];
          }
        }

        for (let r = 0; r < size; r++)
          for (let c = 0; c < size; c++)
            if (grid[r][c] !== oldGrid[r][c]) moved = true;

        if (moved) {
          spawn();
          beep('click');
          draw();
        }
      }

      function keyHandler(e) {
        if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
          e.preventDefault();
          move(e.key.replace('Arrow', '').toLowerCase());
        }
      }

      window.addEventListener('keydown', keyHandler);
      addSwipe(wrap, dir => {
        if (['up', 'down', 'left', 'right'].includes(dir)) move(dir);
      });

      spawn();
      spawn();
      draw();

      return () => window.removeEventListener('keydown', keyHandler);
    }

    // === MEMORY MATCH ===
    function initMemory(root) {
      const symbols = ['üçé', 'üçå', 'üçá', 'üçì', 'üçä', 'ü•ù', 'üçç', 'ü•≠'];
      const cards = [...symbols, ...symbols].sort(() => Math.random() - 0.5);
      
      const grid = document.createElement('div');
      grid.className = 'memory';
      
      const info = document.createElement('h3');
      info.style.textAlign = 'center';
      
      root.append(info, grid);

      let flipped = [];
      let found = 0;
      let moves = 0;
      let canClick = true;

      cards.forEach((c, i) => {
        const d = document.createElement('div');
        d.className = 'mcard';
        d.textContent = '?';
        d.dataset.index = i;
        d.onclick = () => flip(i, d);
        grid.appendChild(d);
      });

      function flip(i, div) {
        if (!canClick || flipped.length === 2 || div.classList.contains('flipped')) return;
        
        div.textContent = cards[i];
        div.classList.add('flipped');
        moves++;
        flipped.push({ i, div });

        if (flipped.length === 2) {
          canClick = false;
          if (cards[flipped[0].i] === cards[flipped[1].i]) {
            beep('win');
            found += 2;
            flipped = [];
            canClick = true;
            if (found === cards.length) {
              info.textContent = `üéâ You won in ${moves} moves!`;
            } else {
              info.textContent = `Moves: ${moves} | Found: ${found/2}/${symbols.length}`;
            }
          } else {
            beep('lose');
            const f0 = flipped[0], f1 = flipped[1];
            setTimeout(() => {
              f0.div.textContent = '?';
              f1.div.textContent = '?';
              f0.div.classList.remove('flipped');
              f1.div.classList.remove('flipped');
              flipped = [];
              canClick = true;
              info.textContent = `Moves: ${moves} | Found: ${found/2}/${symbols.length}`;
            }, 800);
          }
        } else {
          info.textContent = `Moves: ${moves} | Found: ${found/2}/${symbols.length}`;
        }
      }

      info.textContent = `Moves: ${moves} | Found: ${found/2}/${symbols.length}`;
    }

    // === TIC TAC TOE ===
    function initTicTacToe(root) {
      const board = Array(9).fill(null);
      let current = 'X';

      const grid = document.createElement('div');
      grid.className = 'grid-ttt';

      const info = document.createElement('h3');
      info.style.textAlign = 'center';
      info.textContent = 'Your turn (X)';

      root.append(info, grid);
      render();

      function render() {
        grid.innerHTML = '';
        board.forEach((v, i) => {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.textContent = v || '';
          if (!v && current === 'X') cell.onclick = () => move(i);
          grid.appendChild(cell);
        });
      }

      function move(i) {
        if (board[i] || current !== 'X') return;
        board[i] = 'X';
        beep('click');
        render();
        
        if (checkWin('X')) {
          info.textContent = 'üéâ You win!';
          beep('win');
          return;
        }
        if (board.every(c => c)) {
          info.textContent = 'ü§ù Draw!';
          return;
        }

        current = 'O';
        info.textContent = 'AI thinking...';
        setTimeout(compMove, 500);
      }

      function compMove() {
        const idx = bestMove();
        board[idx] = 'O';
        beep('click');
        render();

        if (checkWin('O')) {
          info.textContent = 'üíª AI wins!';
          beep('lose');
          return;
        }
        if (board.every(c => c)) {
          info.textContent = 'ü§ù Draw!';
          return;
        }

        current = 'X';
        info.textContent = 'Your turn (X)';
      }

      function bestMove() {
        let move = findWinningMove('O');
        if (move !== null) return move;

        move = findWinningMove('X');
        if (move !== null) return move;

        if (board[4] === null) return 4;

        const corners = [0, 2, 6, 8].filter(i => board[i] === null);
        if (corners.length) return corners[Math.floor(Math.random() * corners.length)];

        const available = board.reduce((acc, v, i) => v === null ? [...acc, i] : acc, []);
        return available[Math.floor(Math.random() * available.length)];
      }

      function findWinningMove(player) {
        const wins = [
          [0,1,2], [3,4,5], [6,7,8],
          [0,3,6], [1,4,7], [2,5,8],
          [0,4,8], [2,4,6]
        ];
        for (const [a, b, c] of wins) {
          const line = [board[a], board[b], board[c]];
          if (line.filter(v => v === player).length === 2 && line.includes(null)) {
            return [a, b, c][line.indexOf(null)];
          }
        }
        return null;
      }

      function checkWin(player) {
        const wins = [
          [0,1,2], [3,4,5], [6,7,8],
          [0,3,6], [1,4,7], [2,5,8],
          [0,4,8], [2,4,6]
        ];
        return wins.some(([a,b,c]) => 
          board[a] === player && board[b] === player && board[c] === player
        );
      }
    }

    // === SIMON SAYS ===
    function initSimon(root) {
      const colors = ['#ff6b6b', '#4ecdc4', '#ffd93d', '#6bcf7f'];
      const sounds = [440, 554, 659, 880];
      
      const container = document.createElement('div');
      container.style.display = 'grid';
      container.style.gridTemplateColumns = 'repeat(2, 120px)';
      container.style.gap = '10px';
      container.style.margin = '20px auto';
      container.style.width = 'fit-content';
      
      const info = document.createElement('h3');
      info.style.textAlign = 'center';
      info.textContent = 'Watch and repeat!';
      
      const startBtn = document.createElement('button');
      startBtn.className = 'btn';
      startBtn.textContent = 'Start Game';
      startBtn.style.display = 'block';
      startBtn.style.margin = '10px auto';
      
      root.append(info, container, startBtn);

      let sequence = [];
      let playerSequence = [];
      let level = 0;
      let playing = false;
      let canClick = false;

      const buttons = colors.map((color, i) => {
        const btn = document.createElement('div');
        btn.style.width = '120px';
        btn.style.height = '120px';
        btn.style.background = color;
        btn.style.borderRadius = '12px';
        btn.style.cursor = 'pointer';
        btn.style.transition = 'all 0.2s';
        btn.style.boxShadow = '0 4px 8px rgba(0,0,0,0.3)';
        btn.dataset.index = i;
        
        btn.onclick = () => {
          if (!canClick) return;
          playSound(i);
          flashButton(i);
          playerSequence.push(i);
          checkSequence();
        };
        
        container.appendChild(btn);
        return btn;
      });

      function playSound(index) {
        if (!SOUND_ENABLED) return;
        try {
          const ctx = beep.ctx;
          const o = ctx.createOscillator();
          const g = ctx.createGain();
          o.connect(g);
          g.connect(ctx.destination);
          o.frequency.value = sounds[index];
          g.gain.value = 0.1;
          o.start();
          setTimeout(() => o.stop(), 200);
        } catch(e) {}
      }

      function flashButton(index) {
        buttons[index].style.filter = 'brightness(1.5)';
        buttons[index].style.transform = 'scale(0.95)';
        setTimeout(() => {
          buttons[index].style.filter = '';
          buttons[index].style.transform = '';
        }, 300);
      }

      function nextLevel() {
        level++;
        sequence.push(Math.floor(Math.random() * 4));
        info.textContent = `Level ${level}`;
        playSequence();
      }

      async function playSequence() {
        canClick = false;
        await new Promise(r => setTimeout(r, 500));
        
        for (let i = 0; i < sequence.length; i++) {
          await new Promise(r => setTimeout(r, 300));
          playSound(sequence[i]);
          flashButton(sequence[i]);
          await new Promise(r => setTimeout(r, 400));
        }
        
        playerSequence = [];
        canClick = true;
        info.textContent = `Level ${level} - Your turn!`;
      }

      function checkSequence() {
        const index = playerSequence.length - 1;
        
        if (playerSequence[index] !== sequence[index]) {
          info.textContent = `Game Over! Level: ${level}`;
          beep('lose');
          canClick = false;
          playing = false;
          startBtn.textContent = 'Try Again';
          return;
        }

        if (playerSequence.length === sequence.length) {
          canClick = false;
          info.textContent = `Great! Next level...`;
          beep('win');
          setTimeout(nextLevel, 1000);
        }
      }

      startBtn.onclick = () => {
        sequence = [];
        playerSequence = [];
        level = 0;
        playing = true;
        canClick = false;
        startBtn.textContent = 'Playing...';
        nextLevel();
      };
    }

    // === MATH SPRINT ===
    function initMath(root) {
      let score = 0;
      let q = 0;
      const total = 10;

      const info = document.createElement('h3');
      info.style.textAlign = 'center';
      
      const question = document.createElement('p');
      question.style.fontSize = '1.8rem';
      question.style.textAlign = 'center';
      question.style.fontWeight = 'bold';
      question.style.margin = '20px 0';
      
      const inp = document.createElement('input');
      inp.type = 'number';
      inp.style.padding = '16px';
      inp.style.fontSize = '1.3rem';
      inp.style.borderRadius = '12px';
      inp.style.border = '2px solid #cbd5e1';
      inp.style.width = '200px';
      inp.style.textAlign = 'center';
      inp.style.display = 'block';
      inp.style.margin = '10px auto';
      inp.inputMode = 'numeric';
      
      const btn = document.createElement('button');
      btn.className = 'btn';
      btn.textContent = 'Submit';
      btn.style.display = 'block';
      btn.style.margin = '10px auto';

      root.append(info, question, inp, btn);

      function next() {
        if (q === total) {
          question.textContent = `üéâ Quiz Complete!`;
          info.textContent = `Final Score: ${score}/${total}`;
          inp.style.display = 'none';
          btn.style.display = 'none';
          beep('win');
          return;
        }

        q++;
        const a = Math.floor(Math.random() * 12) + 1;
        const b = Math.floor(Math.random() * 12) + 1;
        const ops = ['+', '-', '√ó'];
        const op = ops[Math.floor(Math.random() * ops.length)];
        const ans = op === '+' ? a + b : op === '-' ? a - b : a * b;
        
        question.dataset.ans = ans;
        question.textContent = `${a} ${op} ${b} = ?`;
        inp.value = '';
        inp.focus();
        info.textContent = `Question ${q}/${total} | Score: ${score}`;
      }

      btn.onclick = () => {
        const v = Number(inp.value);
        if (inp.value === '') return;
        
        if (v == Number(question.dataset.ans)) {
          score++;
          beep('win');
        } else {
          beep('lose');
        }
        next();
      };

      inp.onkeypress = e => {
        if (e.key === 'Enter') btn.onclick();
      };

      next();
    }
  </script>
</body>
</html>